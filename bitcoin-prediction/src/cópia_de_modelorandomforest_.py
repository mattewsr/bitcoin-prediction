# -*- coding: utf-8 -*-
"""Cópia de ModeloRandomForest .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Be6HB2935wKLz486XeJzRDeVGkkPlEX5
"""

# ===============================
# 1. Imports
# ===============================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error, r2_score
from sklearn.ensemble import RandomForestRegressor
import warnings

warnings.filterwarnings('ignore')

# ===============================
# 2. Leitura dos Dados
# ===============================
from google.colab import files

uploaded = files.upload()
arquivo = list(uploaded.keys())[0]
df = pd.read_csv(arquivo)
df = df.iloc[::-1].reset_index(drop=True)

# ===============================
# 3. Limpeza dos Dados
# ===============================
def trata_volume(valor):
    valor = str(valor).strip().replace('.', '').replace(',', '.').replace('R$', '')
    if valor.endswith('K'):
        return float(valor[:-1]) * 1_000
    elif valor.endswith('M'):
        return float(valor[:-1]) * 1_000_000
    elif valor.endswith('B'):
        return float(valor[:-1]) * 1_000_000_000
    else:
        try:
            return float(valor)
        except:
            return np.nan

for col in ['Último', 'Abertura', 'Máxima', 'Mínima']:
    df[col] = df[col].astype(str).str.replace('.', '', regex=False)\
        .str.replace(',', '.', regex=False).astype(float)

df['Var%'] = df['Var%'].astype(str).str.replace('%', '', regex=False)\
    .str.replace(',', '.', regex=False).str.replace('−', '-', regex=False).astype(float)
df['Vol.'] = df['Vol.'].apply(trata_volume)

# ===============================
# 4. Criação das Features
# ===============================
df['Vol_USD'] = df['Vol.'] * df['Último']
df['minima_amanha'] = df['Mínima'].shift(-1)
df['maxima_amanha'] = df['Máxima'].shift(-1)
df['media_movel_max_3'] = df['Máxima'].rolling(window=3).mean()
df['vol_relativo'] = df['Vol_USD'] / df['Vol_USD'].shift(1)
df['minima_rel_ultimo'] = (df['Mínima'] - df['Último'].shift(1)) / df['Último'].shift(1)

# Novas features
df['rompeu_topo_historico'] = df['Máxima'] > df['Máxima'].rolling(window=90).max().shift(1)
df['volume_relativo_7d'] = df['Vol_USD'] / df['Vol_USD'].rolling(7).mean()
df['var_pct_3d'] = df['Var%'].rolling(3).mean()

# ===============================
# 5. Seleção de Dados
# ===============================
sub_df = df[['Último', 'Abertura', 'Máxima', 'Mínima', 'Vol_USD', 'Var%',
             'media_movel_max_3', 'vol_relativo', 'minima_rel_ultimo',
             'rompeu_topo_historico', 'volume_relativo_7d', 'var_pct_3d',
             'minima_amanha', 'maxima_amanha']].dropna()

X = sub_df.drop(columns=['minima_amanha', 'maxima_amanha'])
y_min = sub_df['minima_amanha']
y_max = sub_df['maxima_amanha']

# ===============================
# 6. Split de Treino/Teste (70/30)
# ===============================
split_idx = int(len(X) * 0.7)
X_train, X_test = X[:split_idx], X[split_idx:]
y_min_train, y_min_test = y_min[:split_idx], y_min[split_idx:]
y_max_train, y_max_test = y_max[:split_idx], y_max[split_idx:]

# ===============================
# 7. Treinamento dos Modelos (Random Forest)
# ===============================
modelo_min = RandomForestRegressor(n_estimators=100, max_depth=4, random_state=42)
modelo_min.fit(X_train, y_min_train)

modelo_max = RandomForestRegressor(n_estimators=100, max_depth=4, random_state=42)
modelo_max.fit(X_train, y_max_train)

# ===============================
# 8. Previsões
# ===============================
y_min_pred = modelo_min.predict(X_test)
y_max_pred = modelo_max.predict(X_test)

# ===============================
# 9. Visualização dos Resultados
# ===============================
plt.figure(figsize=(15, 8))
y_min_plot = min(min(y_min_test), min(y_min_pred)) * 0.99
y_max_plot = max(max(y_max_test), max(y_max_pred)) * 1.01

plt.plot(y_min_test.values, label='Mínima Real', linestyle='--', linewidth=2, color='blue')
plt.plot(y_min_pred, label='Mínima Prevista', linewidth=2, color='cyan')
plt.plot(y_max_test.values, label='Máxima Real', linestyle='--', linewidth=2, color='red')
plt.plot(y_max_pred, label='Máxima Prevista', linewidth=2, color='orange')

plt.title('Previsão de Mínima e Máxima - Reais vs Previstos (Random Forest)', fontsize=14)
plt.xlabel('Dias', fontsize=12)
plt.ylabel('Preço', fontsize=12)
plt.legend(fontsize=12, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True, linestyle='--', alpha=0.6)
plt.ylim(y_min_plot, y_max_plot)
plt.tight_layout()
plt.show()

# ===============================
# 10. Métricas
# ===============================
def calc_percent_erro(y_true, y_pred, pct):
    erro_rel = np.abs(y_true - y_pred) / y_true
    return (erro_rel <= pct/100).mean() * 100

mae_min = mean_absolute_error(y_min_test, y_min_pred)
erro_rel_min = mae_min / y_min_test.mean() * 100
r2_min = r2_score(y_min_test, y_min_pred) * 100
pct2_min = calc_percent_erro(y_min_test, y_min_pred, 2)
pct5_min = calc_percent_erro(y_min_test, y_min_pred, 5)

mae_max = mean_absolute_error(y_max_test, y_max_pred)
erro_rel_max = mae_max / y_max_test.mean() * 100
r2_max = r2_score(y_max_test, y_max_pred) * 100
pct2_max = calc_percent_erro(y_max_test, y_max_pred, 2)
pct5_max = calc_percent_erro(y_max_test, y_max_pred, 5)

print("========= MÉTRICAS (Random Forest) =========")
print(f"MAE Mínima: {mae_min:.2f}")
print(f"Erro Relativo Mínima (%): {erro_rel_min:.2f}")
print(f"R² Mínima (%): {r2_min:.2f}")
print(f"% Acerto ≤2% Mínima: {pct2_min:.2f}")
print(f"% Acerto ≤5% Mínima: {pct5_min:.2f}")
print("\n---\n")
print(f"MAE Máxima: {mae_max:.2f}")
print(f"Erro Relativo Máxima (%): {erro_rel_max:.2f}")
print(f"R² Máxima (%): {r2_max:.2f}")
print(f"% Acerto ≤2% Máxima: {pct2_max:.2f}")
print(f"% Acerto ≤5% Máxima: {pct5_max:.2f}")

import matplotlib.pyplot as plt
from matplotlib import rcParams

